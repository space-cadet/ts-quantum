
> ts-quantum@1.0.0 test
> vitest run

[33mThe CJS build of Vite's Node API is deprecated. See https://vite.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.[39m

 RUN  v0.34.6 /Users/deepak/code/ts-quantum

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > visualizes eigendecomposition of a 2Ã—2 real symmetric matrix
Input Matrix:
[
  [2.0000, 1.0000],
  [1.0000, 2.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 1.0000
Î»2 = 3.0000

Eigenvectors:
v1 = [0.7071, -0.7071]
v2 = [-0.7071, -0.7071]

Verifying eigenpair 1:
Î» = 1.0000
v = [0.7071, -0.7071]
AÂ·v = [0.7071, -0.7071]
Î»Â·v = [0.7071, -0.7071]
Verification: PASSED âœ“

Verifying eigenpair 2:
Î» = 3.0000
v = [-0.7071, -0.7071]
AÂ·v = [-2.1213, -2.1213]
Î»Â·v = [-2.1213, -2.1213]
Verification: PASSED âœ“

Reconstruction of original matrix:

Eigenvalue Matrix D:
[
  [1.0000, 0.0000],
  [0.0000, 3.0000]
]

VÂ·D:
[
  [0.7071, -2.1213],
  [-0.7071, -2.1213]
]

Reconstructed Matrix VÂ·DÂ·V^T:
[
  [2.0000, 1.0000],
  [1.0000, 2.0000]
]

Original Matrix:
[
  [2.0000, 1.0000],
  [1.0000, 2.0000]
]

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > visualizes eigendecomposition of the Pauli-X matrix
Pauli-X Matrix:
[
  [0.0000, 1.0000],
  [1.0000, 0.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = -1.0000
Î»2 = 1.0000

Eigenvectors:
v1 = [0.7071, -0.7071]
v2 = [-0.7071, -0.7071]

Verifying eigenpair 1:
Î» = -1.0000
v = [0.7071, -0.7071]
AÂ·v = [-0.7071, 0.7071]
Î»Â·v = [-0.7071, 0.7071]
Verification: PASSED âœ“

Verifying eigenpair 2:
Î» = 1.0000
v = [-0.7071, -0.7071]
AÂ·v = [-0.7071, -0.7071]
Î»Â·v = [-0.7071, -0.7071]
Verification: PASSED âœ“

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > visualizes eigendecomposition of a complex Hermitian matrix
Complex Hermitian Matrix:
[
  [1.0000, 1.0000+1.0000i],
  [1.0000-1.0000i, 2.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 0.0000
Î»2 = 3.0000

Eigenvectors:
v1 = [0.8165, -0.4082+0.4082i]
v2 = [-0.5774, -0.5774+0.5774i]

Verifying eigenpair 1:
Î» = 0.0000
v = [0.8165, -0.4082+0.4082i]
AÂ·v = [0.0000, 0.0000]
Î»Â·v = [0.0000, -0.0000]
Verification: PASSED âœ“

Verifying eigenpair 2:
Î» = 3.0000
v = [-0.5774, -0.5774+0.5774i]
AÂ·v = [-1.7321, -1.7321+1.7321i]
Î»Â·v = [-1.7321, -1.7321+1.7321i]
Verification: PASSED âœ“

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles matrices with degenerate eigenvalues
Identity Matrix (Degenerate Case):
[
  [1.0000, 0.0000],
  [0.0000, 1.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 1.0000
Î»2 = 1.0000

Eigenvectors:
v1 = [1.0000, 0.0000]
v2 = [0.0000, 1.0000]

Verifying eigenpair 1:
Î» = 1.0000
v = [1.0000, 0.0000]
AÂ·v = [1.0000, 0.0000]
Î»Â·v = [1.0000, 0.0000]
Verification: PASSED âœ“

Verifying eigenpair 2:
Î» = 1.0000
v = [0.0000, 1.0000]
AÂ·v = [0.0000, 1.0000]
Î»Â·v = [0.0000, 1.0000]
Verification: PASSED âœ“

Checking orthogonality of eigenvectors:
âŸ¨v1|v2âŸ© = 0.0000
Orthogonality: PASSED âœ“

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > tests eigendecomposition of a 3Ã—3 real symmetric matrix
3Ã—3 Real Symmetric Matrix:
[
  [1.0000, 2.0000, 3.0000],
  [2.0000, 2.0000, 1.0000],
  [3.0000, 1.0000, 3.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 1.3845
Î»2 = -1.5283
Î»3 = 6.1439

Eigenvectors:
v1 = [0.8187, -0.3311, -0.4693]
v2 = [0.0200, 0.8331, -0.5528]
v3 = [0.5739, 0.4432, 0.6886]

Verifying eigenpair 1:
Î» = 1.3845
v = [0.8187, -0.3311, -0.4693]
AÂ·v = [-1.2512, 0.5060, 0.7172]
Î»Â·v = [1.1334, -0.4583, -0.6497]
Verification: FAILED âœ—

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > computes eigenvalues only when requested
Computing eigenvalues only:
[
  [3.0000, 1.0000],
  [1.0000, 3.0000]
]

Eigenvalues:
Î»1 = 2.0000
Î»2 = 4.0000
Eigenvectors computed: No

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles the Pauli-Y matrix correctly
Pauli-Y Matrix:
[
  [0.0000, 0.0000-1.0000i],
  [0.0000+1.0000i, 0.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 1.0000
Î»2 = -1.0000

Eigenvectors:
v1 = [1.0000, 0.0000-1.0000i]
v2 = [1.0000, 0.0000+1.0000i]

Verifying eigenpair 1:
Î» = 1.0000
v = [1.0000, 0.0000-1.0000i]
AÂ·v = [-1.0000, 0.0000+1.0000i]
Î»Â·v = [1.0000, 0.0000-1.0000i]
Verification: FAILED âœ—

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles the Pauli-Z matrix correctly
Pauli-Z Matrix:
[
  [1.0000, 0.0000],
  [0.0000, -1.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 1.0000
Î»2 = -1.0000

Eigenvectors:
v1 = [0.0000, 1.0000]
v2 = [1.0000, 0.0000]

Verifying eigenpair 1:
Î» = 1.0000
v = [0.0000, 1.0000]
AÂ·v = [0.0000, -1.0000]
Î»Â·v = [0.0000, 1.0000]
Verification: FAILED âœ—

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles a nilpotent matrix correctly
Nilpotent Matrix:
[
  [0.0000, 1.0000],
  [0.0000, 0.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 0.0000
Î»2 = 0.0000

Eigenvectors:
v1 = [1.0000, 0.0000]

Verifying eigenpair 1:
Î» = 0.0000
v = [1.0000, 0.0000]
AÂ·v = [0.0000, 0.0000]
Î»Â·v = [0.0000, 0.0000]
Verification: PASSED âœ“

Verifying eigenpair 2:
Î» = 0.0000
Skipping undefined eigenvector (deficient case)

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles a matrix with complex eigenvalues
Rotation Matrix (complex eigenvalues):
[
  [0.0000, -1.0000],
  [1.0000, 0.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 0.0000+1.0000i
Î»2 = 0.0000-1.0000i

Eigenvectors:
v1 = [-1.0000, 0.0000+1.0000i]
v2 = [-1.0000, 0.0000-1.0000i]

Verifying eigenpair 1:
Î» = 0.0000+1.0000i
v = [-1.0000, 0.0000+1.0000i]
AÂ·v = [0.0000-1.0000i, -1.0000]
Î»Â·v = [0.0000-1.0000i, -1.0000]
Verification: PASSED âœ“

Verifying eigenpair 2:
Î» = 0.0000-1.0000i
v = [-1.0000, 0.0000-1.0000i]
AÂ·v = [0.0000+1.0000i, -1.0000]
Î»Â·v = [0.0000+1.0000i, -1.0000]
Verification: PASSED âœ“

stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > correctly handles a matrix with very different scales
Matrix with different scales:
[
  [1000000.0000, 0.0000],
  [0.0000, 0.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 0.0000
Î»2 = 1000000.0000

Eigenvectors:
v1 = [0.0000, 1.0000]
v2 = [1.0000, 0.0000]

Verifying eigenpair 1:
Î» = 0.0000
v = [0.0000, 1.0000]
AÂ·v = [0.0000, 0.0000]
Î»Â·v = [0.0000, 0.0000]
Verification: PASSED âœ“

Verifying eigenpair 2:
Î» = 1000000.0000
v = [1.0000, 0.0000]
AÂ·v = [1000000.0000, 0.0000]
Î»Â·v = [1000000.0000, 0.0000]
Verification: PASSED âœ“

 â¯ __tests__/eigen.test.ts  (12 tests | 4 failed) 45ms
   â¯ __tests__/eigen.test.ts > eigenDecomposition Visual Test > tests eigendecomposition of a 3Ã—3 real symmetric matrix
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles the Pauli-Y matrix correctly
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles the Pauli-Z matrix correctly
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/eigen.test.ts > eigenDecomposition Visual Test > verifies full matrix reconstruction for a 3Ã—3 Hermitian matrix
     â†’ expected false to be true // Object.is equality
stdout | __tests__/eigen.test.ts > eigenDecomposition Visual Test > verifies full matrix reconstruction for a 3Ã—3 Hermitian matrix
3Ã—3 Hermitian Matrix:
[
  [2.0000, 1.0000+1.0000i, 0.0000],
  [1.0000-1.0000i, 2.0000, 0.0000+1.0000i],
  [0.0000, 0.0000-1.0000i, 2.0000]
]

Performing eigendecomposition...

Eigenvalues:
Î»1 = 0.2679
Î»2 = 2.0000
Î»3 = 3.7321

Eigenvectors:
v1 = [-1.2663, 1.0966-1.0966i, 0.6331+0.6331i]
v2 = [0.4082-0.4082i, -0.0000, 0.8165]
v3 = [-0.0547, -0.0474+0.0474i, 0.0274+0.0274i]

Eigenvalue Matrix D:
[
  [0.2679, 0.0000, 0.0000],
  [0.0000, 2.0000, 0.0000],
  [0.0000, 0.0000, 3.7321]
]

VÂ·D:
[
  [-0.3393, 2.1933-2.1933i, 2.3629+2.3629i],
  [0.1094-0.1094i, 0.0000, 3.0472],
  [-0.0147, -0.0948+0.0948i, 0.1021+0.1021i]
]

Vâ€  (Conjugate Transpose):
[
  [-1.2663, 0.4082+0.4082i, -0.0547],
  [1.0966+1.0966i, -0.0000, -0.0474-0.0474i],
  [0.6331-0.6331i, 0.8165, 0.0274-0.0274i]
]

Reconstructed Matrix VÂ·DÂ·Vâ€ :
[
  [8.2323, 1.7908+1.7908i, -0.0600],
  [1.7908-1.7908i, 2.5774, 0.0774-0.0774i],
  [-0.0600, 0.0774+0.0774i, 0.0154]
]

Original Matrix:
[
  [2.0000, 1.0000+1.0000i, 0.0000],
  [1.0000-1.0000i, 2.0000, 0.0000+1.0000i],
  [0.0000, 0.0000-1.0000i, 2.0000]
]

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > computes correct eigenvalues and eigenvectors for 2x2 matrix
Matrix:
[
  [2.000, 1.000],
  [1.000, 2.000]
]
Eigenvalues: [1.000, 3.000]
Eigenvectors:
[
  [0.707, -0.707],
  [-0.707, -0.707]
]
Verifying eigenpair 0: {
  eigenvalue: Complex { re: [33m1[39m, im: [33m0[39m },
  eigenvector: [
    Complex { re: [33m0.7071067811865476[39m, im: [33m0[39m },
    Complex { re: [33m-0.7071067811865475[39m, im: [33m0[39m }
  ]
}
Verifying eigenpair 1: {
  eigenvalue: Complex { re: [33m3[39m, im: [33m0[39m },
  eigenvector: [
    Complex { re: [33m-0.7071067811865475[39m, im: [33m0[39m },
    Complex { re: [33m-0.7071067811865476[39m, im: [33m0[39m }
  ]
}
Verifying full decomposition
Eigenvalues: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m3[39m, im: [33m0[39m } ]
Eigenvector matrix V:
[
  [0.707, -0.707],
  [-0.707, -0.707]
]
Diagonal matrix D:
[
  [1.000, 0.000],
  [0.000, 3.000]
]
Conjugate transpose Vâ€ :
[
  [0.707, -0.707],
  [-0.707, -0.707]
]
VÂ·D:
[
  [0.707, -2.121],
  [-0.707, -2.121]
]
VÂ·DÂ·Vâ€ :
[
  [2.000, 1.000],
  [1.000, 2.000]
]
Original matrix:
[
  [2.000, 1.000],
  [1.000, 2.000]
]
Reconstructed matrix:
[
  [2.000, 1.000],
  [1.000, 2.000]
]

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > computes correct eigenvalues and eigenvectors for random 2x2 matrix
Random Matrix:
[
  [1.400, -1.514],
  [-1.514, 0.832]
]
Eigenvalues: [-0.425, 2.657]
Eigenvectors:
[
  [0.639, 0.770],
  [-0.770, 0.639]
]
Verifying full decomposition
Eigenvalues: [
  Complex { re: [33m-0.4245576166797707[39m, im: [33m0[39m },
  Complex { re: [33m2.656965807969574[39m, im: [33m0[39m }
]
Eigenvector matrix V:
[
  [0.639, 0.770],
  [-0.770, 0.639]
]
Diagonal matrix D:
[
  [-0.425, 0.000],
  [0.000, 2.657]
]
Conjugate transpose Vâ€ :
[
  [0.639, -0.770],
  [0.770, 0.639]
]
VÂ·D:
[
  [-0.271, 2.045],
  [0.327, 1.697]
]
VÂ·DÂ·Vâ€ :
[
  [1.400, 1.514],
  [1.514, 0.832]
]
Original matrix:
[
  [1.400, -1.514],
  [-1.514, 0.832]
]
Reconstructed matrix:
[
  [1.400, 1.514],
  [1.514, 0.832]
]
Mismatch at [0,1]: Original=-1.514, Reconstructed=1.514

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > computes eigensystem for Pauli X matrix
PauliX matrix:
[
  [0.000, 1.000],
  [1.000, 0.000]
]
Eigenvalues: [-1.000, 1.000]
Eigenvectors:
[
  [0.707, -0.707],
  [-0.707, -0.707]
]
Eigenvalues: [ Complex { re: [33m-1[39m, im: [33m0[39m }, Complex { re: [33m1[39m, im: [33m0[39m } ]
Eigenvector matrix V:
[
  [0.707, -0.707],
  [-0.707, -0.707]
]
Diagonal matrix D:
[
  [-1.000, 0.000],
  [0.000, 1.000]
]
Conjugate transpose Vâ€ :
[
  [0.707, -0.707],
  [-0.707, -0.707]
]
VÂ·D:
[
  [-0.707, -0.707],
  [0.707, -0.707]
]
VÂ·DÂ·Vâ€ :
[
  [0.000, 1.000],
  [1.000, 0.000]
]
Original matrix:
[
  [0.000, 1.000],
  [1.000, 0.000]
]
Reconstructed matrix:
[
  [0.000, 1.000],
  [1.000, 0.000]
]

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > handles matrices with degenerate eigenvalues
Eigenvalues: [
  Complex { re: [33m1[39m, im: [33m0[39m },
  Complex { re: [33m1[39m, im: [33m0[39m },
  Complex { re: [33m1[39m, im: [33m0[39m }
]
Eigenvector matrix V:
[
  [1.000, 0.000, 0.000],
  [0.000, 1.000, 0.000],
  [0.000, 0.000, 1.000]
]
Diagonal matrix D:
[
  [1.000, 0.000, 0.000],
  [0.000, 1.000, 0.000],
  [0.000, 0.000, 1.000]
]
Conjugate transpose Vâ€ :
[
  [1.000, 0.000, 0.000],
  [0.000, 1.000, 0.000],
  [0.000, 0.000, 1.000]
]
VÂ·D:
[
  [1.000, 0.000, 0.000],
  [0.000, 1.000, 0.000],
  [0.000, 0.000, 1.000]
]
VÂ·DÂ·Vâ€ :
[
  [1.000, 0.000, 0.000],
  [0.000, 1.000, 0.000],
  [0.000, 0.000, 1.000]
]
Original matrix:
[
  [1.000, 0.000, 0.000],
  [0.000, 1.000, 0.000],
  [0.000, 0.000, 1.000]
]
Reconstructed matrix:
[
  [1.000, 0.000, 0.000],
  [0.000, 1.000, 0.000],
  [0.000, 0.000, 1.000]
]

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > correctly decomposes larger real symmetric matrices
Vectors before orthonormality check: 0.7369762290995789,0.3279852776056809,-0.5910090485061031,-0.5910090485061027,0.7369762290995787,-0.3279852776056823,0.32798527760568175,0.5910090485061035,0.7369762290995784

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Complex Hermitian Matrices > computes correct eigensystem for Pauli Y matrix
Verifying Pauli Y eigenpair 0:
Eigenvalue: 1.000
Eigenvector: [0.707, 0.000-0.707i]

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Numerical Stability and Edge Cases > handles matrices with zeros
Matrix with zeros:
Matrix:
[
  [0.000, 1.000],
  [1.000, 0.000]
]
Eigenvalues: [-1.000, 1.000]
Eigenvectors:
[
  [0.707, -0.707],
  [0.707, 0.707]
]
Eigenvalues: [ Complex { re: [33m-1[39m, im: [33m0[39m }, Complex { re: [33m1[39m, im: [33m0[39m } ]
Eigenvector matrix V:
[
  [0.707, -0.707],
  [0.707, 0.707]
]
Diagonal matrix D:
[
  [-1.000, 0.000],
  [0.000, 1.000]
]
Conjugate transpose Vâ€ :
[
  [0.707, 0.707],
  [-0.707, 0.707]
]
VÂ·D:
[
  [-0.707, -0.707],
  [-0.707, 0.707]
]
VÂ·DÂ·Vâ€ :
[
  [0.000, -1.000],
  [-1.000, 0.000]
]
Original matrix:
[
  [0.000, 1.000],
  [1.000, 0.000]
]
Reconstructed matrix:
[
  [0.000, -1.000],
  [-1.000, 0.000]
]
Mismatch at [0,1]: Original=1.000, Reconstructed=-1.000

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Quantum-Specific Applications > correctly decomposes Pauli Z matrix
v0 vector: [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m1[39m, im: [33m0[39m } ]
v0[0].re: [33m0[39m

stdout | __tests__/eigendecomposition.test.ts > Eigendecomposition > Quantum-Specific Applications > correctly decomposes a Hamiltonian
Verifying Hamiltonian eigenpair 0:
Eigenvalue: 0.000
Eigenvector: [0.000, 0.707, -0.707, 0.000]

 â¯ __tests__/eigendecomposition.test.ts  (20 tests | 7 failed) 69ms
   â¯ __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > computes correct eigenvalues and eigenvectors for random 2x2 matrix
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > correctly decomposes larger real symmetric matrices
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/eigendecomposition.test.ts > Eigendecomposition > Complex Hermitian Matrices > computes correct eigensystem for Pauli Y matrix
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/eigendecomposition.test.ts > Eigendecomposition > Complex Hermitian Matrices > handles general complex Hermitian matrices
     â†’ Expected eigenvectors to be defined
   â¯ __tests__/eigendecomposition.test.ts > Eigendecomposition > Numerical Stability and Edge Cases > handles matrices with zeros
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/eigendecomposition.test.ts > Eigendecomposition > Quantum-Specific Applications > correctly decomposes Pauli Z matrix
     â†’ expected 1 to be less than 1e-10
   â¯ __tests__/eigendecomposition.test.ts > Eigendecomposition > Quantum-Specific Applications > correctly decomposes a Hamiltonian
     â†’ expected false to be true // Object.is equality
 â¯ __tests__/integration.test.ts  (8 tests | 3 failed) 12ms
   â¯ __tests__/integration.test.ts > Quantum Integration Tests > Space and State Integration > handles tensor products of states correctly
     â†’ b.getAmplitudes is not a function
   â¯ __tests__/integration.test.ts > Quantum Integration Tests > Operator and Space Integration > correctly extends operators to larger spaces
     â†’ b.getAmplitudes is not a function
   â¯ __tests__/integration.test.ts > Quantum Integration Tests > Complex Quantum Circuits > creates and manipulates Bell states
     â†’ b.getAmplitudes is not a function
stdout | __tests__/geometry/quantumDistance.test.ts > Bloch Sphere Geometry > quantum distance matches Bloch sphere calculation
State1:  StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|Î¸=0.00,Ï†=0.00âŸ©'[39m,
  properties: [90mundefined[39m
}
State2:  StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [
    Complex { re: [33m6.123233995736766e-17[39m, im: [33m0[39m },
    Complex { re: [33m1[39m, im: [33m0[39m }
  ],
  basis: [32m'|Î¸=3.14,Ï†=0.00âŸ©'[39m,
  properties: [90mundefined[39m
}
Quantum Distance:  [33m1.414213562373095[39m
Bloch Distance:  [33m1.4142135623730951[39m
Bloch sphere verification:  [33mtrue[39m
State1:  StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|Î¸=0.00,Ï†=0.00âŸ©'[39m,
  properties: [90mundefined[39m
}
State2:  StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [
    Complex { re: [33m0.7071067811865476[39m, im: [33m0[39m },
    Complex { re: [33m0.7071067811865475[39m, im: [33m0[39m }
  ],
  basis: [32m'|Î¸=1.57,Ï†=0.00âŸ©'[39m,
  properties: [90mundefined[39m
}
Quantum Distance:  [33m0.7653668647301795[39m
Bloch Distance:  [33m1[39m
Bloch sphere verification:  [33mfalse[39m

 â¯ __tests__/geometry/quantumDistance.test.ts  (15 tests | 1 failed) 9ms
   â¯ __tests__/geometry/quantumDistance.test.ts > Bloch Sphere Geometry > quantum distance matches Bloch sphere calculation
     â†’ expected false to be true // Object.is equality
 â¯ __tests__/matrixFunctions.test.ts  (5 tests | 2 failed) 44ms
   â¯ __tests__/matrixFunctions.test.ts > matrixFunction > applies identity function to return the same matrix
     â†’ expected false to be true // Object.is equality
   â¯ __tests__/matrixFunctions.test.ts > matrixFunction > applies square function to eigenvalues correctly
     â†’ expected false to be true // Object.is equality
stdout | __tests__/matrixFunctions.test.ts > matrixFunction > applies identity function to return the same matrix
[
  [2.0000, 1.0000],
  [1.0000, 2.0000]
]
[
  [2.0000, -1.0000],
  [-1.0000, 2.0000]
]

stdout | __tests__/matrixFunctions.test.ts > matrixFunction > applies square function to eigenvalues correctly
[
  [2.0000, 1.0000],
  [1.0000, 2.0000]
]
[
  [5.0000, -4.0000],
  [-4.0000, 5.0000]
]

 â¯ __tests__/angularMomentum/wigner3j.test.ts  (12 tests | 3 failed) 8ms
   â¯ __tests__/angularMomentum/wigner3j.test.ts > Wigner 3j Symbols > Known values validation > should calculate (1/2 1/2 1; 1/2 -1/2 0) = -1/sqrt(6)
     â†’ expected 0.408248290463863 to be close to -0.4082482904638631, received difference is 0.816496580927726, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner3j.test.ts > Wigner 3j Symbols > Symmetry properties > should transform correctly under odd permutations
     â†’ expected 0.7302967433402214 to be close to 0.04564354645876384, received difference is 0.6846531968814575, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner3j.test.ts > Wigner 3j Symbols > Symmetry properties > should be invariant under sign reversal of all m values
     â†’ expected -0.632455532033676 to be close to -0.158113883008419, received difference is 0.474341649025257, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts  (11 tests | 8 failed) 11ms
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Known values from Varshalovich > should calculate {1/2 1/2 1; 1/2 1/2 0} = -1/3
     â†’ expected -0.08333333333333333 to be close to -0.3333333333333333, received difference is 0.25, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Known values from Varshalovich > should calculate {1 1 2; 1 1 0} = 1/(2âˆš5)
     â†’ expected 0.0027777777777777796 to be close to 0.22360679774997896, received difference is 0.2208290199722012, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Known values from Varshalovich > should calculate {3/2 3/2 3; 3/2 3/2 0} = -1/(2âˆš5)
     â†’ expected -0.000049603174603174596 to be close to -0.22360679774997896, received difference is 0.2235571945753758, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Special cases from theory > should handle zero argument case correctly
     â†’ expected -0.013888888888888897 to be close to 0.3333333333333333, received difference is 0.3472222222222222, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Special cases from theory > should handle equal pairs case correctly
     â†’ expected 0.000277777777777778 to be close to 0.1, received difference is 0.09972222222222223, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Symmetry properties > should satisfy Regge symmetry
     â†’ expected 0.000277777777777778 to be close to 0.0003105649968749709, received difference is 0.00003278721909719291, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Sum rules > should satisfy orthogonality relation
     â†’ expected 0.00001388888888888891 to be close to 0.3333333333333333, received difference is 0.33331944444444445, but expected 5e-7
   â¯ __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Sum rules > should satisfy Racah backcoupling rule
     â†’ expected -0.010416666666666671 to be close to 1, received difference is 1.0104166666666667, but expected 5e-7
 â¯ __tests__/graph/utils.test.ts  (0 test)
 â¯ __tests__/graph/QuantumGraph.test.ts  (0 test)
 â¯ __tests__/qgraph/general-operations.test.ts  (0 test)
 â¯ __tests__/algorithms/quantumWalk/quantumWalk.test.ts  (0 test)
 â¯ test/graph/builders/spinNetwork.test.ts  (0 test)
stdout | unknown test
state1: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
state2: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
state3: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m1[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,-0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Combined state: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m4[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|(0.5,0.5),1,1âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension: [33m4[39m
Combined state 2: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m4[39m,
  amplitudes: [
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0.7071067811865476[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m-0.7071067811865476[39m, im: [33m0[39m }
  ],
  basis: [32m'|(0.5,0.5),1,0âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension 2: [33m4[39m

stdout | __tests__/angularMomentum/composition.test.ts > Angular Momentum Composition > Clebsch-Gordan Coefficients > should return zero for coefficients that violate selection rules
CG Rule Violation (m â‰  m1 + m2): j1=1, m1=1, j2=1, m2=0, j=2, m=0 => CG = Complex { re: [33m0[39m, im: [33m0[39m }
CG Rule Violation (j > j1 + j2): j1=1, m1=1, j2=1, m2=1, j=3, m=2 => CG = Complex { re: [33m0[39m, im: [33m0[39m }
CG Rule Violation (j < |j1 - j2|): j1=2, m1=1, j2=1, m2=0, j=0, m=1 => CG = Complex { re: [33m0[39m, im: [33m0[39m }

stdout | __tests__/angularMomentum/composition.test.ts > Angular Momentum Composition > Clebsch-Gordan Coefficients > should correctly calculate coefficients for two spin-1/2 particles
CG Singlet state: j1=1/2, m1=1/2, j2=1/2, m2=-1/2, j=0, m=0 => CG = Complex { re: [33m-0.7071067811865475[39m, im: [33m0[39m } Expected: -1/âˆš2 = [33m-0.7071067811865475[39m
CG Singlet state: j1=1/2, m1=-1/2, j2=1/2, m2=1/2, j=0, m=0 => CG = Complex { re: [33m0.7071067811865475[39m, im: [33m0[39m } Expected: 1/âˆš2 = [33m0.7071067811865475[39m
CG Triplet state (m=1): j1=1/2, m1=1/2, j2=1/2, m2=1/2, j=1, m=1 => CG = Complex { re: [33m1[39m, im: [33m0[39m } Expected: 1
CG Triplet state (m=0): j1=1/2, m1=1/2, j2=1/2, m2=-1/2, j=1, m=0 => CG = Complex { re: [33m0.7071067811865475[39m, im: [33m0[39m } Expected: 1/âˆš2 = [33m0.7071067811865475[39m
CG Triplet state (m=-1): j1=1/2, m1=-1/2, j2=1/2, m2=-1/2, j=1, m=-1 => CG = Complex { re: [33m1[39m, im: [33m0[39m } Expected: 1

stdout | __tests__/angularMomentum/composition.test.ts > Angular Momentum Composition > Clebsch-Gordan Coefficients > should correctly calculate coefficients for j1=1, j2=1/2 case
CG j1=1, j2=1/2 case: j1=1, m1=1, j2=1/2, m2=1/2, j=3/2, m=3/2 => CG = Complex { re: [33m1[39m, im: [33m0[39m } Expected: 1
CG j1=1, j2=1/2 case: j1=1, m1=1, j2=1/2, m2=-1/2, j=3/2, m=1/2 => CG = Complex { re: [33m1.1547005383792517[39m, im: [33m0[39m } Expected: âˆš(2/3) = [33m0.816496580927726[39m

 â¯ __tests__/angularMomentum/composition.test.ts  (8 tests | 1 failed) 13ms
   â¯ __tests__/angularMomentum/composition.test.ts > Angular Momentum Composition > Clebsch-Gordan Coefficients > should correctly calculate coefficients for j1=1, j2=1/2 case
     â†’ expected 0.33820395745152565 to be less than 1e-10
stdout | __tests__/angularMomentum/composition.test.ts > Angular Momentum Composition > Angular Momentum Addition > should have correct amplitude for |j=1, m=1âŸ© component
Complex { re: [33m0[39m, im: [33m0[39m }

 âœ“ __tests__/information.test.ts  (19 tests) 18ms
 âœ“ __tests__/hamiltonian.test.ts  (10 tests) 19ms
stdout | __tests__/hamiltonian.test.ts > Hamiltonian > Spin Hamiltonian > should create correct spin Hamiltonian
Spin Hamiltonian
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0.000  1.000 â”‚
â”‚ 1.000  0.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Initial state:  0.7071067811865475|0âŸ© + 0.7071067811865475|1âŸ©
Evolved state:  -0.7071067811865475|0âŸ© + -0.7071067811865475|1âŸ©
[33mtrue[39m

stdout | __tests__/hamiltonian.test.ts > Hamiltonian > Heisenberg Hamiltonian > should create correct Heisenberg Hamiltonian
Heisenberg Hamiltonian
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1.000   0.000   0.000   0.000 â”‚
â”‚  0.000  -1.000   2.000   0.000 â”‚
â”‚  0.000   2.000  -1.000   0.000 â”‚
â”‚  0.000   0.000   0.000   1.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Up up state:  1|0âŸ©
Expectation value:  Complex { re: [33m1[39m, im: [33m0[39m }
Singlet state:   + 0.7071067811865475|1âŸ© + -0.7071067811865475|2âŸ©
Singlet Expectation Value:  Complex { re: [33m-2.9999999999999996[39m, im: [33m0[39m }

stdout | __tests__/hamiltonian.test.ts > Hamiltonian > Heisenberg Hamiltonian > evolves product and entangled states correctly
Heisenberg Hamiltonian:  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1.000   0.000   0.000   0.000 â”‚
â”‚  0.000  -1.000   2.000   0.000 â”‚
â”‚  0.000   2.000  -1.000   0.000 â”‚
â”‚  0.000   0.000   0.000   1.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Up up state:  1|0âŸ©
Evolved up up state:  -1.0000000000000018|0âŸ©
Evolution operator:  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ -1.000   0.000   0.000   0.000 â”‚
â”‚  0.000  -1.000   0.000   0.000 â”‚
â”‚  0.000   0.000  -1.000   0.000 â”‚
â”‚  0.000   0.000   0.000  -1.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Up down state:   + 1|1âŸ©
Evolved up down state:   + -1.0000000000000115|1âŸ©
StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m4[39m,
  amplitudes: [
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m-1.0000000000000115[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|01âŸ©'[39m,
  properties: [90mundefined[39m
}
Overlap with up down state:  Complex { re: [33m-1.0000000000000115[39m, im: [33m0[39m }

stdout | __tests__/hamiltonian.test.ts > Hamiltonian > Error handling > should throw on non-Hermitian terms when required
Is Hermitian?:  [33mfalse[39m

 âœ“ __tests__/angularMomentum/states.test.ts  (10 tests) 14ms
stdout | __tests__/angularMomentum/states.test.ts > Angular Momentum States > Raising and Lowering Operations > should correctly raise states
Expected state: 1|0âŸ©

stdout | __tests__/densityMatrix.test.ts > Quantum Channels > Specific Channels > implements phase flip channel correctly
Channel: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0.000  0.000 â”‚
â”‚ 0.000  0.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜,â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1.000   0.000 â”‚
â”‚  0.000  -1.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
State: 0.7071067811865475|0âŸ© + 0.7071067811865475|1âŸ©
Rho: [
  [0.5000, 0.5000],
  [0.5000, 0.5000]
]
Phase flip result: [
  [0.5000, -0.5000],
  [-0.5000, 0.5000]
]

 âœ“ __tests__/densityMatrix.test.ts  (28 tests) 38ms
 âœ“ __tests__/scalability.test.ts  (3 tests) 353ms
stdout | __tests__/scalability.test.ts > Quantum Module Scalability > State Vector Scaling > should handle increasing qubit counts
1 qubits (dim 2): 0.50ms, ~0.0MB
2 qubits (dim 4): 0.12ms, ~0.0MB
3 qubits (dim 8): 0.09ms, ~0.0MB
4 qubits (dim 16): 0.16ms, ~0.1MB
5 qubits (dim 32): 0.82ms, ~0.4MB
6 qubits (dim 64): 1.14ms, ~0.2MB
7 qubits (dim 128): 2.83ms, ~0.4MB
8 qubits (dim 256): 1.15ms, ~1.1MB
9 qubits (dim 512): 1.71ms, ~0.9MB
10 qubits (dim 1024): 2.98ms, ~1.8MB
11 qubits (dim 2048): 5.36ms, ~2.9MB
12 qubits (dim 4096): 15.91ms, ~-5.0MB
13 qubits (dim 8192): 29.81ms, ~-11.4MB
14 qubits (dim 16384): 38.22ms, ~7.5MB
15 qubits (dim 32768): 98.26ms, ~2.4MB
16 qubits (dim 65536): 145.53ms, ~3.1MB

stdout | __tests__/scalability.test.ts > Quantum Module Scalability > Tensor Product Scaling > should handle tensor products up to memory limits
Tensor product 1 qubits: 0.01ms, dim 2, ~0.0MB
Tensor product 2 qubits: 0.04ms, dim 4, ~0.0MB
Tensor product 3 qubits: 0.01ms, dim 8, ~0.0MB
Tensor product 4 qubits: 0.01ms, dim 16, ~0.0MB
Tensor product 5 qubits: 0.01ms, dim 32, ~0.0MB
Tensor product 6 qubits: 0.02ms, dim 64, ~0.0MB
Tensor product 7 qubits: 0.04ms, dim 128, ~0.0MB
Tensor product 8 qubits: 0.15ms, dim 256, ~0.1MB

stdout | __tests__/scalability.test.ts > Quantum Module Scalability > Operator Scaling > should handle operator creation and application
Starting 1 qubits (dim 2)...
Operator 1 qubits: 0.07ms, ~0.0MB
Starting 2 qubits (dim 4)...
Operator 2 qubits: 0.01ms, ~0.0MB
Starting 3 qubits (dim 8)...
Operator 3 qubits: 0.01ms, ~0.0MB
Starting 4 qubits (dim 16)...
Operator 4 qubits: 0.01ms, ~0.0MB
Starting 5 qubits (dim 32)...
Operator 5 qubits: 0.01ms, ~0.0MB
Starting 6 qubits (dim 64)...
Operator 6 qubits: 0.01ms, ~0.0MB
Starting 7 qubits (dim 128)...
Operator 7 qubits: 0.02ms, ~0.0MB
Starting 8 qubits (dim 256)...
Operator 8 qubits: 0.03ms, ~0.0MB

stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes sorting order for 2Ã—2 real symmetric matrix

ğŸ§ª TEST: 2Ã—2 Real Symmetric Matrix

============================================================
2Ã—2 Real Symmetric: Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [3.0000, 1.0000],
  [1.0000, 2.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 1.3820 (magnitude: 1.381966)
  Î»1: 3.6180 (magnitude: 3.618034)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»1 = 3.6180 (mag: 3.618034)
    Position 1: Î»0 = 1.3820 (mag: 1.381966)

  By Real Part (descending):
    Position 0: Î»1 = 3.6180 (Re: 3.618034)
    Position 1: Î»0 = 1.3820 (Re: 1.381966)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âŒ NO
  Sorted by real part: âŒ NO
  âš ï¸ Eigenvalues are in their natural order (implementation-dependent)

ğŸ­ Eigenvectors:
  v0 (for Î»0): [-0.5257, 0.8507]
  Verification for eigenpair 0:
  âœ… Eigenpair verification passed
  v1 (for Î»1): [0.8507, 0.5257]
  Verification for eigenpair 1:
  âœ… Eigenpair verification passed

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 1.3820 â†” v0 = [-0.5257, 0.8507]
  Î»1 = 3.6180 â†” v1 = [0.8507, 0.5257]

============================================================

ğŸ“ Theoretical eigenvalues: 3.618034, 1.381966
ğŸ“ Computed magnitudes: 3.618034, 1.381966

stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes sorting order for Pauli matrices

ğŸ§ª TEST: Pauli Matrices Sorting Analysis

============================================================
Pauli-X: Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [0.0000, 1.0000],
  [1.0000, 0.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: -1.0000 (magnitude: 1.000000)
  Î»1: 1.0000 (magnitude: 1.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»0 = -1.0000 (mag: 1.000000)
    Position 1: Î»1 = 1.0000 (mag: 1.000000)

  By Real Part (descending):
    Position 0: Î»1 = 1.0000 (Re: 1.000000)
    Position 1: Î»0 = -1.0000 (Re: -1.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âœ… YES
  Sorted by real part: âŒ NO

ğŸ­ Eigenvectors:
  v0 (for Î»0): [0.7071, -0.7071]
  Verification for eigenpair 0:
  âœ… Eigenpair verification passed
  v1 (for Î»1): [0.7071, 0.7071]
  Verification for eigenpair 1:
  âœ… Eigenpair verification passed

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = -1.0000 â†” v0 = [0.7071, -0.7071]
  Î»1 = 1.0000 â†” v1 = [0.7071, 0.7071]

============================================================


============================================================
Pauli-Y: Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [0.0000, 0.0000-1.0000i],
  [0.0000+1.0000i, 0.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 1.0000 (magnitude: 1.000000)
  Î»1: -1.0000 (magnitude: 1.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»0 = 1.0000 (mag: 1.000000)
    Position 1: Î»1 = -1.0000 (mag: 1.000000)

  By Real Part (descending):
    Position 0: Î»0 = 1.0000 (Re: 1.000000)
    Position 1: Î»1 = -1.0000 (Re: -1.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âœ… YES
  Sorted by real part: âœ… YES

ğŸ­ Eigenvectors:
  v0 (for Î»0): [1.0000, 0.0000-1.0000i]
  Verification for eigenpair 0:
  âŒ Eigenpair verification failed at component 0: error = 2.000e+0
  v1 (for Î»1): [1.0000, 0.0000+1.0000i]
  Verification for eigenpair 1:
  âŒ Eigenpair verification failed at component 0: error = 2.000e+0

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 1.0000 â†” v0 = [1.0000, 0.0000-1.0000i]
  Î»1 = -1.0000 â†” v1 = [1.0000, 0.0000+1.0000i]

============================================================


============================================================
Pauli-Z: Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [1.0000, 0.0000],
  [0.0000, -1.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 1.0000 (magnitude: 1.000000)
  Î»1: -1.0000 (magnitude: 1.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»0 = 1.0000 (mag: 1.000000)
    Position 1: Î»1 = -1.0000 (mag: 1.000000)

  By Real Part (descending):
    Position 0: Î»0 = 1.0000 (Re: 1.000000)
    Position 1: Î»1 = -1.0000 (Re: -1.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âœ… YES
  Sorted by real part: âœ… YES

ğŸ­ Eigenvectors:
  v0 (for Î»0): [0.0000, 1.0000]
  Verification for eigenpair 0:
  âŒ Eigenpair verification failed at component 1: error = 2.000e+0
  v1 (for Î»1): [1.0000, 0.0000]
  Verification for eigenpair 1:
  âŒ Eigenpair verification failed at component 0: error = 2.000e+0

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 1.0000 â†” v0 = [0.0000, 1.0000]
  Î»1 = -1.0000 â†” v1 = [1.0000, 0.0000]

============================================================

ğŸ¯ Pauli-X eigenvalues (sorted): [1.000000, -1.000000]
ğŸ¯ Pauli-Y eigenvalues (sorted): [1.000000, -1.000000]
ğŸ¯ Pauli-Z eigenvalues (sorted): [1.000000, -1.000000]

stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes sorting order for diagonal matrix with known eigenvalues

ğŸ§ª TEST: Diagonal Matrix (Known Eigenvalues)

============================================================
3Ã—3 Diagonal: Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [5.0000, 0.0000, 0.0000],
  [0.0000, 2.0000, 0.0000],
  [0.0000, 0.0000, 8.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 2.0000 (magnitude: 2.000000)
  Î»1: 5.0000 (magnitude: 5.000000)
  Î»2: 8.0000 (magnitude: 8.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»2 = 8.0000 (mag: 8.000000)
    Position 1: Î»1 = 5.0000 (mag: 5.000000)
    Position 2: Î»0 = 2.0000 (mag: 2.000000)

  By Real Part (descending):
    Position 0: Î»2 = 8.0000 (Re: 8.000000)
    Position 1: Î»1 = 5.0000 (Re: 5.000000)
    Position 2: Î»0 = 2.0000 (Re: 2.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âŒ NO
  Sorted by real part: âŒ NO
  âš ï¸ Eigenvalues are in their natural order (implementation-dependent)

ğŸ­ Eigenvectors:
  v0 (for Î»0): [0.0000, 1.0000, 0.0000]
  Verification for eigenpair 0:
  âœ… Eigenpair verification passed
  v1 (for Î»1): [1.0000, 0.0000, 0.0000]
  Verification for eigenpair 1:
  âœ… Eigenpair verification passed
  v2 (for Î»2): [0.0000, 0.0000, 1.0000]
  Verification for eigenpair 2:
  âœ… Eigenpair verification passed

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 2.0000 â†” v0 = [0.0000, 1.0000, 0.0000]
  Î»1 = 5.0000 â†” v1 = [1.0000, 0.0000, 0.0000]
  Î»2 = 8.0000 â†” v2 = [0.0000, 0.0000, 1.0000]

============================================================

ğŸ“ Expected diagonal elements: [5, 2, 8]
ğŸ“ Computed eigenvalue reals: [2.000000, 5.000000, 8.000000]

stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes sorting order for complex Hermitian matrix

ğŸ§ª TEST: Complex Hermitian Matrix

============================================================
2Ã—2 Complex Hermitian: Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [2.0000, 1.0000+1.0000i],
  [1.0000-1.0000i, 3.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 1.0000 (magnitude: 1.000000)
  Î»1: 4.0000 (magnitude: 4.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»1 = 4.0000 (mag: 4.000000)
    Position 1: Î»0 = 1.0000 (mag: 1.000000)

  By Real Part (descending):
    Position 0: Î»1 = 4.0000 (Re: 4.000000)
    Position 1: Î»0 = 1.0000 (Re: 1.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âŒ NO
  Sorted by real part: âŒ NO
  âš ï¸ Eigenvalues are in their natural order (implementation-dependent)

ğŸ­ Eigenvectors:
  v0 (for Î»0): [2.3094, -1.1547+1.1547i]
  Verification for eigenpair 0:
  âœ… Eigenpair verification passed
  v1 (for Î»1): [0.5774, 0.5774-0.5774i]
  Verification for eigenpair 1:
  âœ… Eigenpair verification passed

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 1.0000 â†” v0 = [2.3094, -1.1547+1.1547i]
  Î»1 = 4.0000 â†” v1 = [0.5774, 0.5774-0.5774i]

============================================================

ğŸ” Hermitian Property Check:
  Î»0 imaginary part: 0.000e+0 âœ…
  Î»1 imaginary part: 0.000e+0 âœ…

stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes sorting order for degenerate eigenvalues

ğŸ§ª TEST: Degenerate Eigenvalues (Identity Matrix)

============================================================
2Ã—2 Identity (Degenerate): Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [1.0000, 0.0000],
  [0.0000, 1.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 1.0000 (magnitude: 1.000000)
  Î»1: 1.0000 (magnitude: 1.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»0 = 1.0000 (mag: 1.000000)
    Position 1: Î»1 = 1.0000 (mag: 1.000000)

  By Real Part (descending):
    Position 0: Î»0 = 1.0000 (Re: 1.000000)
    Position 1: Î»1 = 1.0000 (Re: 1.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âœ… YES
  Sorted by real part: âœ… YES

ğŸ­ Eigenvectors:
  v0 (for Î»0): [1.0000, 0.0000]
  Verification for eigenpair 0:
  âœ… Eigenpair verification passed
  v1 (for Î»1): [0.0000, 1.0000]
  Verification for eigenpair 1:
  âœ… Eigenpair verification passed

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 1.0000 â†” v0 = [1.0000, 0.0000]
  Î»1 = 1.0000 â†” v1 = [0.0000, 1.0000]

============================================================

ğŸ” Degeneracy Check:
  Î»0 - 1 = 0.000e+0 âœ…
  Î»1 - 1 = 0.000e+0 âœ…
ğŸ” Orthogonality Check: âŸ¨v1|v2âŸ© = 0.0000
  Orthogonality error: 0.000e+0 âœ…

stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes sorting order for complex eigenvalues

ğŸ§ª TEST: Complex Eigenvalues (Rotation Matrix)

============================================================
2Ã—2 Rotation (Complex Eigenvalues): Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [0.0000, -1.0000],
  [1.0000, 0.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 0.0000+1.0000i (magnitude: 1.000000)
  Î»1: 0.0000-1.0000i (magnitude: 1.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»0 = 0.0000+1.0000i (mag: 1.000000)
    Position 1: Î»1 = 0.0000-1.0000i (mag: 1.000000)

  By Real Part (descending):
    Position 0: Î»0 = 0.0000+1.0000i (Re: 0.000000)
    Position 1: Î»1 = 0.0000-1.0000i (Re: 0.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âœ… YES
  Sorted by real part: âœ… YES

ğŸ­ Eigenvectors:
  v0 (for Î»0): [-1.0000, 0.0000+1.0000i]
  Verification for eigenpair 0:
  âœ… Eigenpair verification passed
  v1 (for Î»1): [-1.0000, 0.0000-1.0000i]
  Verification for eigenpair 1:
  âœ… Eigenpair verification passed

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 0.0000+1.0000i â†” v0 = [-1.0000, 0.0000+1.0000i]
  Î»1 = 0.0000-1.0000i â†” v1 = [-1.0000, 0.0000-1.0000i]

============================================================

ğŸ” Complex Eigenvalue Check:
  Expected: 0.0000+1.0000i, Got: 0.0000+1.0000i
  Real error: 0.000e+0, Imag error: 0.000e+0
  Expected: 0.0000-1.0000i, Got: 0.0000-1.0000i
  Real error: 0.000e+0, Imag error: 0.000e+0

stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes sorting consistency across multiple decompositions

ğŸ§ª TEST: Sorting Consistency Check
ğŸ”„ Running eigendecomposition multiple times...

  Run 1:
    Eigenvalues: [-0.3028, 3.3028, 5.0000]

  Run 2:
    Eigenvalues: [-0.3028, 3.3028, 5.0000]

  Run 3:
    Eigenvalues: [-0.3028, 3.3028, 5.0000]

ğŸ” Consistency Analysis:
  Run 1 vs Run 2: âœ… Consistent
  Run 1 vs Run 3: âœ… Consistent

ğŸ¯ Overall Consistency: âœ… PASSED
  âœ¨ Eigenvalue ordering is deterministic and consistent!

 âœ“ __tests__/eigenSorting.test.ts  (8 tests) 37ms
stdout | __tests__/eigenSorting.test.ts > Eigendecomposition Sorting Order Tests > analyzes eigenvalue precision and numerical stability

ğŸ§ª TEST: Numerical Precision Analysis

============================================================
Large Scale Difference: Eigendecomposition Sorting Analysis
============================================================

ğŸ“Š Input Matrix:
[
  [0.0000, 1.0000],
  [1.0000, 100000000.0000]
]

ğŸ”¢ Raw Eigenvalues (as returned by eigenDecomposition):
  Î»0: 0.0000 (magnitude: 0.000000)
  Î»1: 100000000.0000 (magnitude: 100000000.000000)

ğŸ“ˆ Sorting Analysis:

  By Magnitude (descending):
    Position 0: Î»1 = 100000000.0000 (mag: 100000000.000000)
    Position 1: Î»0 = 0.0000 (mag: 0.000000)

  By Real Part (descending):
    Position 0: Î»1 = 100000000.0000 (Re: 100000000.000000)
    Position 1: Î»0 = 0.0000 (Re: 0.000000)

ğŸ¯ Sorting Status:
  Sorted by magnitude: âŒ NO
  Sorted by real part: âŒ NO
  âš ï¸ Eigenvalues are in their natural order (implementation-dependent)

ğŸ­ Eigenvectors:
  v0 (for Î»0): [1.0000, -0.0000]
  Verification for eigenpair 0:
  âœ… Eigenpair verification passed
  v1 (for Î»1): [0.0000, 1.0000]
  Verification for eigenpair 1:
  âœ… Eigenpair verification passed

ğŸ”— Eigenvalue-Eigenvector Correspondence:
  Î»0 = 0.0000 â†” v0 = [1.0000, -0.0000]
  Î»1 = 100000000.0000 â†” v1 = [0.0000, 1.0000]

============================================================

ğŸ” Numerical Stability Check:
  Eigenvalue magnitude range: 0.000e+0 to 1.000e+8
  Condition number (approx): Infinity
  âœ… Eigenpair verification passed
  âœ… Eigenpair verification passed
  Eigenpair verification: âœ… All valid

stdout | __tests__/operatorAlgebra.test.ts > Operator Algebra > nestedCommutator > calculates nested commutator structure
Matrix representation: MatrixOperator {
  objectType: [32m'operator'[39m,
  dimension: [33m2[39m,
  type: [32m'general'[39m,
  matrix: [ [ [36m[Complex][39m, [36m[Complex][39m ], [ [36m[Complex][39m, [36m[Complex][39m ] ],
  validateTypeConstraints: [33mtrue[39m
}

stdout | __tests__/operatorAlgebra.test.ts > Operator Algebra > operatorsCommute > returns false for non-commuting operators
[
  [ Complex { re: [33m0[39m, im: [33m2[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m-2[39m } ]
]
[33mfalse[39m

 âœ“ __tests__/operatorAlgebra.test.ts  (17 tests) 34ms
stdout | unknown test
Jx: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0.000  0.707  0.000 â”‚
â”‚ 0.707  0.000  0.707 â”‚
â”‚ 0.000  0.707  0.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Jy: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        0.000  0.000-0.707i         0.000 â”‚
â”‚ 0.000+0.707i         0.000  0.000-0.707i â”‚
â”‚        0.000  0.000+0.707i         0.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Jz: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1.000   0.000   0.000 â”‚
â”‚  0.000   0.000   0.000 â”‚
â”‚  0.000   0.000  -1.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

stdout | __tests__/angularMomentum/operators.test.ts > Angular Momentum Operators > j=1/2 Matrix Representations > should have correct JÂ± matrix elements
J+: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0.000  1.000 â”‚
â”‚ 0.000  0.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
J-: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0.000  0.000 â”‚
â”‚ 1.000  0.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
[
  [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m1[39m, im: [33m0[39m } ],
  [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ]
]

stdout | __tests__/angularMomentum/operators.test.ts > Angular Momentum Operators > j=1/2 Matrix Representations > should have correct Jy matrix elements
Jy: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        0.000  0.000-0.500i â”‚
â”‚ 0.000+0.500i         0.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Matrix: [
  [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m-0.5[39m } ],
  [ Complex { re: [33m0[39m, im: [33m0.5[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ]
]

stdout | __tests__/angularMomentum/operators.test.ts > Angular Momentum Operators > Eigenvalue Equations > should satisfy Jz eigenvalue equation
Jz â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  0.500   0.000 â”‚
â”‚  0.000  -0.500 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

stdout | __tests__/angularMomentum/operators.test.ts > Angular Momentum Operators > Commutation Relations > should satisfy [Jx,Jy] = iJz
Commutator: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0.000+1.000i         0.000         0.000 â”‚
â”‚        0.000         0.000         0.000 â”‚
â”‚        0.000         0.000  0.000-1.000i â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Expected Result: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0.000+1.000i         0.000         0.000 â”‚
â”‚        0.000         0.000         0.000 â”‚
â”‚        0.000         0.000  0.000-1.000i â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

stdout | __tests__/angularMomentum/operators.test.ts > Angular Momentum Operators > JÂ² Construction > should give same results for both JÂ² construction methods
JÂ² Direct: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2.000  0.000  0.000 â”‚
â”‚ 0.000  2.000  0.000 â”‚
â”‚ 0.000  0.000  2.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
JÂ² From Components: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2.000  0.000  0.000 â”‚
â”‚ 0.000  2.000  0.000 â”‚
â”‚ 0.000  0.000  2.000 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

 âœ“ __tests__/angularMomentum/operators.test.ts  (11 tests) 9ms
 âœ“ __tests__/matrixOperations.test.ts  (25 tests) 29ms
 âœ“ __tests__/angularMomentum/indexing.test.ts  (20 tests) 17ms
stdout | __tests__/angularMomentum/indexing.test.ts > Angular Momentum Indexing Consistency > Matrix Element Verification > should have correct J+ matrix elements for j=1/2
[
  [0.0000, 1.0000],
  [0.0000, 0.0000]
]

stdout | __tests__/angularMomentum/indexing.test.ts > Angular Momentum Indexing Consistency > Matrix Element Verification > should have correct J- matrix elements for j=1/2
[
  [0.0000, 0.0000],
  [1.0000, 0.0000]
]

stdout | __tests__/angularMomentum/indexing.test.ts > Angular Momentum Indexing Consistency > Matrix Element Verification > should have correct Jz matrix elements for j=1/2
[
  [0.5000, 0.0000],
  [0.0000, -0.5000]
]

stdout | __tests__/angularMomentum/indexing.test.ts > Angular Momentum Indexing Consistency > Angular Momentum Coupling Indexing > should produce correct Clebsch-Gordan coefficients
CG Coefficients:
cg1:  Complex { re: [33m1[39m, im: [33m0[39m }
cg2:  Complex { re: [33m0.7071067811865475[39m, im: [33m0[39m }
cg3:  Complex { re: [33m-0.7071067811865475[39m, im: [33m0[39m }

 âœ“ __tests__/operators/sparse.test.ts  (17 tests) 10ms
stdout | __tests__/operators/sparse.test.ts > Sparse Matrix Utilities > Matrix-Matrix Operations > should multiply sparse matrices
Matrix A:
{
  entries: [
    { row: [33m0[39m, col: [33m0[39m, value: [32m'1 + 0i'[39m },
    { row: [33m1[39m, col: [33m1[39m, value: [32m'2 + 0i'[39m }
  ],
  nnz: [33m2[39m
}
Matrix B:
{
  entries: [
    { row: [33m0[39m, col: [33m0[39m, value: [32m'3 + 0i'[39m },
    { row: [33m1[39m, col: [33m1[39m, value: [32m'4 + 0i'[39m }
  ],
  nnz: [33m2[39m
}
Result Matrix:
{
  entries: [
    { row: [33m0[39m, col: [33m0[39m, value: [32m'3 + 0i'[39m },
    { row: [33m1[39m, col: [33m1[39m, value: [32m'8 + 0i'[39m }
  ],
  nnz: [33m2[39m
}

stdout | __tests__/operators/sparse.test.ts > Sparse Matrix Utilities > Conversion Operations > should convert sparse to dense
Sparse Matrix:
{
  entries: [
    { row: [33m0[39m, col: [33m1[39m, value: [32m'3 + 0i'[39m },
    { row: [33m1[39m, col: [33m0[39m, value: [32m'4 + 0i'[39m }
  ],
  nnz: [33m2[39m
}
Dense Matrix:
[ [ [32m'0 + 0i'[39m, [32m'3 + 0i'[39m ], [ [32m'4 + 0i'[39m, [32m'0 + 0i'[39m ] ]

stdout | __tests__/operators/sparse.test.ts > Sparse Matrix Utilities > Matrix Properties > should identify identity matrix
Identity Matrix:
{
  entries: [
    { row: [33m0[39m, col: [33m0[39m, value: [32m'1 + 0i'[39m },
    { row: [33m1[39m, col: [33m1[39m, value: [32m'1 + 0i'[39m },
    { row: [33m2[39m, col: [33m2[39m, value: [32m'1 + 0i'[39m }
  ],
  nnz: [33m3[39m
}
Non-Identity Matrix:
{
  entries: [
    { row: [33m0[39m, col: [33m0[39m, value: [32m'1 + 0i'[39m },
    { row: [33m1[39m, col: [33m1[39m, value: [32m'1 + 0i'[39m },
    { row: [33m2[39m, col: [33m2[39m, value: [32m'1 + 0i'[39m },
    { row: [33m0[39m, col: [33m1[39m, value: [32m'0.1 + 0i'[39m }
  ],
  nnz: [33m4[39m
}

stdout | __tests__/operators/sparse.test.ts > Sparse Matrix Utilities > Validation and Cleanup > should remove zero entries
Matrix before removing zeros:
{
  entries: [
    { row: [33m0[39m, col: [33m0[39m, value: [32m'1 + 0i'[39m },
    { row: [33m1[39m, col: [33m1[39m, value: [32m'2 + 0i'[39m }
  ],
  nnz: [33m2[39m
}
Matrix after removing zeros:
{
  entries: [
    { row: [33m0[39m, col: [33m0[39m, value: [32m'1 + 0i'[39m },
    { row: [33m1[39m, col: [33m1[39m, value: [32m'2 + 0i'[39m }
  ],
  nnz: [33m2[39m
}

stdout | __tests__/operators/specialized.test.ts > Specialized Operators > DiagonalOperator > should detect zero operator
Zero Diagonal Values:
[ [32m'0 + 0i'[39m, [32m'0 + 0i'[39m ]
Non-Zero Diagonal Values:
[ [32m'0 + 0i'[39m, [32m'1e-15 + 0i'[39m ]
Zero Diagonal Operator: DiagonalOperator {
  objectType: [32m'operator'[39m,
  type: [32m'diagonal'[39m,
  dimension: [33m2[39m,
  diagonal: [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ]
}
Non-Zero Diagonal Operator: DiagonalOperator {
  objectType: [32m'operator'[39m,
  type: [32m'diagonal'[39m,
  dimension: [33m2[39m,
  diagonal: [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m1e-15[39m, im: [33m0[39m } ]
}

Zero Detection Results:
Zero Operator (default tolerance): [33mtrue[39m
Non-Zero Operator (default tolerance): [33mtrue[39m
Non-Zero Operator (tolerance 1e-14): [33mtrue[39m

 âœ“ __tests__/operators/specialized.test.ts  (31 tests) 16ms
 âœ“ __tests__/states.test.ts  (17 tests) 7ms
 âœ“ __tests__/oscillator.test.ts  (5 tests) 16ms
 âœ“ __tests__/angularMomentum/composition_visualization.test.ts  (6 tests) 10ms
stdout | __tests__/angularMomentum/composition_visualization.test.ts > Angular Momentum Addition Visualization > Two spin-1/2 particles > should show addition of parallel spins (â†‘â†‘)

ğŸ“Š Adding two spin-1/2 particles with mâ‚ = mâ‚‚ = +1/2 (â†‘â†‘)

============================================================
First spin-1/2:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 2
Basis: |0.5,0.5âŸ©
============================================================

============================================================
Second spin-1/2:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 2
Basis: |0.5,0.5âŸ©
============================================================

============================================================
Combined state:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m4[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|(0.5,0.5),1,1âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension: 4
Basis: |(0.5,0.5),1,1âŸ©
============================================================

stdout | __tests__/angularMomentum/composition_visualization.test.ts > Angular Momentum Addition Visualization > Two spin-1/2 particles > should show addition of antiparallel spins (â†‘â†“)

ğŸ“Š Adding two spin-1/2 particles with mâ‚ = +1/2, mâ‚‚ = -1/2 (â†‘â†“)

============================================================
Spin up:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 2
Basis: |0.5,0.5âŸ©
============================================================

============================================================
Spin down:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m0[39m, im: [33m0[39m }, Complex { re: [33m1[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,-0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 2
Basis: |0.5,-0.5âŸ©
============================================================

============================================================
Combined state:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m4[39m,
  amplitudes: [
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0.7071067811865476[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m-0.7071067811865476[39m, im: [33m0[39m }
  ],
  basis: [32m'|(0.5,0.5),1,0âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension: 4
Basis: |(0.5,0.5),1,0âŸ©
============================================================

stdout | __tests__/angularMomentum/composition_visualization.test.ts > Angular Momentum Addition Visualization > Spin-1 and spin-1/2 particles > should show addition of maximum m states

ğŸ“Š Adding spin-1 (m=1) and spin-1/2 (m=1/2) particles

============================================================
Spin-1:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m3[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|1,1âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 3
Basis: |1,1âŸ©
============================================================

============================================================
Spin-1/2:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 2
Basis: |0.5,0.5âŸ©
============================================================

============================================================
Combined state:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m6[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|(1,0.5),1.5,1.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension: 6
Basis: |(1,0.5),1.5,1.5âŸ©
============================================================

stdout | __tests__/angularMomentum/composition_visualization.test.ts > Angular Momentum Addition Visualization > Spin-1 and spin-1/2 particles > should show addition with intermediate m states

ğŸ“Š Adding spin-1 (m=0) and spin-1/2 (m=1/2) particles

============================================================
Spin-1:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m3[39m,
  amplitudes: [
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|1,0âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 3
Basis: |1,0âŸ©
============================================================

============================================================
Spin-1/2:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m0.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 2
Basis: |0.5,0.5âŸ©
============================================================

============================================================
Combined state:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m6[39m,
  amplitudes: [
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0.8164965809277261[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m-0.5773502691896258[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|(1,0.5),1.5,0.5âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1.5[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension: 6
Basis: |(1,0.5),1.5,0.5âŸ©
============================================================

stdout | __tests__/angularMomentum/composition_visualization.test.ts > Angular Momentum Addition Visualization > Two spin-1 particles > should show addition of maximum aligned spins

ğŸ“Š Adding two spin-1 particles with maximum m values

============================================================
First spin-1:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m3[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|1,1âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 3
Basis: |1,1âŸ©
============================================================

============================================================
Second spin-1:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m3[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|1,1âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 3
Basis: |1,1âŸ©
============================================================

============================================================
Combined state:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m9[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|(1,1),2,2âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m2[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension: 9
Basis: |(1,1),2,2âŸ©
============================================================

stdout | __tests__/angularMomentum/composition_visualization.test.ts > Angular Momentum Addition Visualization > Two spin-1 particles > should show addition of orthogonal spins

ğŸ“Š Adding two spin-1 particles with mâ‚=1, mâ‚‚=0

============================================================
First spin-1:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m3[39m,
  amplitudes: [
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|1,1âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 3
Basis: |1,1âŸ©
============================================================

============================================================
Second spin-1:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m3[39m,
  amplitudes: [
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|1,0âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m1[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mfalse[39m
    }
  }
}
Dimension: 3
Basis: |1,0âŸ©
============================================================

============================================================
Combined state:
State vector: StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m9[39m,
  amplitudes: [
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m1[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m },
    Complex { re: [33m0[39m, im: [33m0[39m }
  ],
  basis: [32m'|(1,1),2,1âŸ©'[39m,
  properties: {
    angularMomentumMetadata: {
      type: [32m'angular_momentum'[39m,
      j: [33m2[39m,
      mRange: [36m[Array][39m,
      couplingHistory: [36m[Array][39m,
      jComponents: [36m[Map][39m,
      isComposite: [33mtrue[39m
    }
  }
}
Dimension: 9
Basis: |(1,1),2,1âŸ©
============================================================

 âœ“ __tests__/stateVector.test.ts  (29 tests) 16ms
 âœ“ __tests__/operator.test.ts  (20 tests) 12ms
 âœ“ __tests__/gates.test.ts  (18 tests) 8ms
 âœ“ __tests__/hilbertSpace.test.ts  (20 tests) 12ms
stdout | __tests__/hilbertSpace.test.ts > HilbertSpace > Instance Methods > computationalBasisState > creates valid basis states
HilbertSpace { dimension: [33m2[39m, basis: [ [32m'|0âŸ©'[39m, [32m'|1âŸ©'[39m ] } 
 StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0âŸ©'[39m,
  properties: [90mundefined[39m
} 
 StateVector {
  objectType: [32m'state'[39m,
  dimension: [33m2[39m,
  amplitudes: [ Complex { re: [33m1[39m, im: [33m0[39m }, Complex { re: [33m0[39m, im: [33m0[39m } ],
  basis: [32m'|0âŸ©'[39m,
  properties: [90mundefined[39m
}
[33mtrue[39m

 âœ“ __tests__/measurement.test.ts  (8 tests) 7ms
 âœ“ __tests__/validation.test.ts  (15 tests) 7ms
 âœ“ __tests__/composition.test.ts  (13 tests) 4ms
 âœ“ __tests__/core/quantumObject.test.ts  (10 tests) 3ms

â¯â¯â¯â¯â¯â¯ Failed Suites 5 â¯â¯â¯â¯â¯â¯â¯

 FAIL  __tests__/graph/QuantumGraph.test.ts [ __tests__/graph/QuantumGraph.test.ts ]
 FAIL  __tests__/graph/utils.test.ts [ __tests__/graph/utils.test.ts ]
 FAIL  __tests__/qgraph/general-operations.test.ts [ __tests__/qgraph/general-operations.test.ts ]
Error: Failed to load url ../../src/qgraph/QuantumGraph (resolved id: ../../src/qgraph/QuantumGraph) in /Users/deepak/code/ts-quantum/__tests__/graph/utils.test.ts. Does the file exist?
 â¯ loadAndTransform node_modules/vite/dist/node/chunks/dep-C6uTJdX2.js:51968:17

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[1/34]â¯

 FAIL  __tests__/algorithms/quantumWalk/quantumWalk.test.ts [ __tests__/algorithms/quantumWalk/quantumWalk.test.ts ]
Error: Failed to load url @spin-network/graph-core/src/core/builders (resolved id: @spin-network/graph-core/src/core/builders) in /Users/deepak/code/ts-quantum/__tests__/algorithms/quantumWalk/quantumWalk.test.ts. Does the file exist?
 â¯ loadAndTransform node_modules/vite/dist/node/chunks/dep-C6uTJdX2.js:51968:17

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[2/34]â¯

 FAIL  test/graph/builders/spinNetwork.test.ts [ test/graph/builders/spinNetwork.test.ts ]
Error: Failed to load url ../../../src/graph/builders/spinNetwork (resolved id: ../../../src/graph/builders/spinNetwork) in /Users/deepak/code/ts-quantum/test/graph/builders/spinNetwork.test.ts. Does the file exist?
 â¯ loadAndTransform node_modules/vite/dist/node/chunks/dep-C6uTJdX2.js:51968:17

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[3/34]â¯

â¯â¯â¯â¯â¯â¯ Failed Tests 29 â¯â¯â¯â¯â¯â¯â¯

 FAIL  __tests__/eigen.test.ts > eigenDecomposition Visual Test > tests eigendecomposition of a 3Ã—3 real symmetric matrix
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ verifyEigenpairs __tests__/eigen.test.ts:68:21
     66|     
     67|     console.log(`Verification: ${isValid ? 'PASSED âœ“' : 'FAILED âœ—'}`);
     68|     expect(isValid).toBe(true);
       |                     ^
     69|   }
     70| }
 â¯ __tests__/eigen.test.ts:282:7

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[4/34]â¯

 FAIL  __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles the Pauli-Y matrix correctly
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ verifyEigenpairs __tests__/eigen.test.ts:68:21
     66|     
     67|     console.log(`Verification: ${isValid ? 'PASSED âœ“' : 'FAILED âœ—'}`);
     68|     expect(isValid).toBe(true);
       |                     ^
     69|   }
     70| }
 â¯ __tests__/eigen.test.ts:345:7

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[5/34]â¯

 FAIL  __tests__/eigen.test.ts > eigenDecomposition Visual Test > handles the Pauli-Z matrix correctly
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ verifyEigenpairs __tests__/eigen.test.ts:68:21
     66|     
     67|     console.log(`Verification: ${isValid ? 'PASSED âœ“' : 'FAILED âœ—'}`);
     68|     expect(isValid).toBe(true);
       |                     ^
     69|   }
     70| }
 â¯ __tests__/eigen.test.ts:380:7

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[6/34]â¯

 FAIL  __tests__/eigen.test.ts > eigenDecomposition Visual Test > verifies full matrix reconstruction for a 3Ã—3 Hermitian matrix
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/eigen.test.ts:585:58
    583|       
    584|       // Verify they're approximately equal
    585|       expect(matricesApproxEqual(matrix, reconstructed)).toBe(true);
       |                                                          ^
    586|     }
    587|   });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[7/34]â¯

 FAIL  __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > computes correct eigenvalues and eigenvectors for random 2x2 matrix
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/eigendecomposition.test.ts:240:60
    238|       // And verify the full decomposition
    239|       console.log('Verifying full decomposition');
    240|       expect(verifyDecomposition(matrix, values, vectors)).toBe(true);
       |                                                            ^
    241|       
    242|       // Additional verification that eigenvalues are real (symmetric â€¦

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[8/34]â¯

 FAIL  __tests__/eigendecomposition.test.ts > Eigendecomposition > Real Symmetric Matrices > correctly decomposes larger real symmetric matrices
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/eigendecomposition.test.ts:328:12
    326|           values[i],
    327|           vectors[i]
    328|         )).toBe(true);
       |            ^
    329|       }
    330|       

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[9/34]â¯

 FAIL  __tests__/eigendecomposition.test.ts > Eigendecomposition > Complex Hermitian Matrices > computes correct eigensystem for Pauli Y matrix
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/eigendecomposition.test.ts:368:64
    366|         console.log(`Eigenvalue: ${formatComplex(values[i])}`);
    367|         console.log(`Eigenvector: [${vectors[i].map(formatComplex).joiâ€¦
    368|         expect(verifyEigenPair(pauliY, values[i], vectors[i])).toBe(trâ€¦
       |                                                                ^
    369|       }
    370|     });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[10/34]â¯

 FAIL  __tests__/eigendecomposition.test.ts > Eigendecomposition > Complex Hermitian Matrices > handles general complex Hermitian matrices
Error: Expected eigenvectors to be defined
 â¯ __tests__/eigendecomposition.test.ts:386:15
    384|       // Since we explicitly requested eigenvectors, they should be deâ€¦
    385|       if (!vectors) {
    386|         throw new Error('Expected eigenvectors to be defined');
       |               ^
    387|       }
    388| 

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[11/34]â¯

 FAIL  __tests__/eigendecomposition.test.ts > Eigendecomposition > Numerical Stability and Edge Cases > handles matrices with zeros
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/eigendecomposition.test.ts:576:60
    574|       
    575|       // Verify decomposition
    576|       expect(verifyDecomposition(matrix, values, vectors)).toBe(true);
       |                                                            ^
    577|     });
    578|     

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[12/34]â¯

 FAIL  __tests__/eigendecomposition.test.ts > Eigendecomposition > Quantum-Specific Applications > correctly decomposes Pauli Z matrix
AssertionError: expected 1 to be less than 1e-10
 â¯ __tests__/eigendecomposition.test.ts:639:38
    637|       console.log('v0 vector:', v0);
    638|       console.log('v0[0].re:', v0[0].re);
    639|       expect(Math.abs(v0[0].re - 1)).toBeLessThan(1e-10);
       |                                      ^
    640|       expect(Math.abs(v0[1].re)).toBeLessThan(1e-10);
    641|       

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[13/34]â¯

 FAIL  __tests__/eigendecomposition.test.ts > Eigendecomposition > Quantum-Specific Applications > correctly decomposes a Hamiltonian
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/eigendecomposition.test.ts:698:69
    696|         console.log(`Eigenvalue: ${formatComplex(values[i])}`);
    697|         console.log(`Eigenvector: [${vectors[i].map(formatComplex).joiâ€¦
    698|         expect(verifyEigenPair(hamiltonian, values[i], vectors[i])).toâ€¦
       |                                                                     ^
    699|       }
    700|     });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[14/34]â¯

 FAIL  __tests__/integration.test.ts > Quantum Integration Tests > Space and State Integration > handles tensor products of states correctly
TypeError: b.getAmplitudes is not a function
 â¯ Module.stateVectorApproxEqual __tests__/utils/testHelpers.ts:45:19
     43|   if (a.dimension !== b.dimension) return false;
     44|   const aAmps = a.getAmplitudes();
     45|   const bAmps = b.getAmplitudes();
       |                   ^
     46|   // console.log(aAmps, bAmps);
     47|   return aAmps.every((amp, i) => complexApproxEqual(amp, bAmps[i], tolâ€¦
 â¯ __tests__/integration.test.ts:38:14

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[15/34]â¯

 FAIL  __tests__/integration.test.ts > Quantum Integration Tests > Operator and Space Integration > correctly extends operators to larger spaces
TypeError: b.getAmplitudes is not a function
 â¯ Module.stateVectorApproxEqual __tests__/utils/testHelpers.ts:45:19
     43|   if (a.dimension !== b.dimension) return false;
     44|   const aAmps = a.getAmplitudes();
     45|   const bAmps = b.getAmplitudes();
       |                   ^
     46|   // console.log(aAmps, bAmps);
     47|   return aAmps.every((amp, i) => complexApproxEqual(amp, bAmps[i], tolâ€¦
 â¯ __tests__/integration.test.ts:86:14

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[16/34]â¯

 FAIL  __tests__/integration.test.ts > Quantum Integration Tests > Complex Quantum Circuits > creates and manipulates Bell states
TypeError: b.getAmplitudes is not a function
 â¯ Module.stateVectorApproxEqual __tests__/utils/testHelpers.ts:45:19
     43|   if (a.dimension !== b.dimension) return false;
     44|   const aAmps = a.getAmplitudes();
     45|   const bAmps = b.getAmplitudes();
       |                   ^
     46|   // console.log(aAmps, bAmps);
     47|   return aAmps.every((amp, i) => complexApproxEqual(amp, bAmps[i], tolâ€¦
 â¯ __tests__/integration.test.ts:164:14

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[17/34]â¯

 FAIL  __tests__/matrixFunctions.test.ts > matrixFunction > applies identity function to return the same matrix
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/matrixFunctions.test.ts:49:43
     47|     const result = matrixFunction(matrix, identityFn);
     48|     console.log(formatMatrix(result));
     49|     expect(matricesEqual(result, matrix)).toBe(true);
       |                                           ^
     50|   });
     51|   

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[18/34]â¯

 FAIL  __tests__/matrixFunctions.test.ts > matrixFunction > applies square function to eigenvalues correctly
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/matrixFunctions.test.ts:70:51
     68|     ];
     69|     
     70|     expect(matricesEqual(result, expected, 1e-9)).toBe(true);
       |                                                   ^
     71|   });
     72|   

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[19/34]â¯

 FAIL  __tests__/angularMomentum/composition.test.ts > Angular Momentum Composition > Clebsch-Gordan Coefficients > should correctly calculate coefficients for j1=1, j2=1/2 case
AssertionError: expected 0.33820395745152565 to be less than 1e-10
 â¯ __tests__/angularMomentum/composition.test.ts:63:77
     61|       const c2 = clebschGordan(1, 1, 0.5, -0.5, 1.5, 0.5);
     62|       console.log('CG j1=1, j2=1/2 case: j1=1, m1=1, j2=1/2, m2=-1/2, â€¦
     63|       expect(math.abs(math.subtract((c2 as any).re ?? c2, Math.sqrt(2/â€¦
       |                                                                             ^
     64|       
     65|       const c3 = clebschGordan(1, 0, 0.5, 0.5, 1.5, 0.5);

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[20/34]â¯

 FAIL  __tests__/angularMomentum/wigner3j.test.ts > Wigner 3j Symbols > Known values validation > should calculate (1/2 1/2 1; 1/2 -1/2 0) = -1/sqrt(6)
AssertionError: expected 0.408248290463863 to be close to -0.4082482904638631, received difference is 0.816496580927726, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner3j.test.ts:59:25
     57|     it('should calculate (1/2 1/2 1; 1/2 -1/2 0) = -1/sqrt(6)', () => {
     58|       const result = wigner3j(0.5, 0.5, 1, 0.5, -0.5, 0);
     59|       expect(result.re).toBeCloseTo(-1 / Math.sqrt(6), 6);
       |                         ^
     60|       expect(math.abs(result.im)).toBeCloseTo(0, 10);
     61|     });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[21/34]â¯

 FAIL  __tests__/angularMomentum/wigner3j.test.ts > Wigner 3j Symbols > Symmetry properties > should transform correctly under odd permutations
AssertionError: expected 0.7302967433402214 to be close to 0.04564354645876384, received difference is 0.6846531968814575, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner3j.test.ts:86:27
     84|       // Odd permutation should give phase (-1)^(j1+j2+j3)
     85|       const phase = Math.pow(-1, j1 + j2 + j3);
     86|       expect(original.re).toBeCloseTo(phase * odd1.re, 6);
       |                           ^
     87|     });
     88| 

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[22/34]â¯

 FAIL  __tests__/angularMomentum/wigner3j.test.ts > Wigner 3j Symbols > Symmetry properties > should be invariant under sign reversal of all m values
AssertionError: expected -0.632455532033676 to be close to -0.158113883008419, received difference is 0.474341649025257, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner3j.test.ts:99:27
     97|       const expectedValue = math.multiply(signReversed, expectedPhase)â€¦
     98|       
     99|       expect(original.re).toBeCloseTo(expectedValue.re, 6);
       |                           ^
    100|       expect(original.im).toBeCloseTo(expectedValue.im, 6);
    101|     });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[23/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Known values from Varshalovich > should calculate {1/2 1/2 1; 1/2 1/2 0} = -1/3
AssertionError: expected -0.08333333333333333 to be close to -0.3333333333333333, received difference is 0.25, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:28:25
     26|     it('should calculate {1/2 1/2 1; 1/2 1/2 0} = -1/3', () => {
     27|       const result = wigner6j(0.5, 0.5, 1, 0.5, 0.5, 0);
     28|       expect(result.re).toBeCloseTo(-1/3, 6);
       |                         ^
     29|       expect(math.abs(result.im)).toBeCloseTo(0, 10);
     30|     });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[24/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Known values from Varshalovich > should calculate {1 1 2; 1 1 0} = 1/(2âˆš5)
AssertionError: expected 0.0027777777777777796 to be close to 0.22360679774997896, received difference is 0.2208290199722012, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:34:25
     32|     it('should calculate {1 1 2; 1 1 0} = 1/(2âˆš5)', () => {
     33|       const result = wigner6j(1, 1, 2, 1, 1, 0);
     34|       expect(result.re).toBeCloseTo(1/(2*Math.sqrt(5)), 6);
       |                         ^
     35|       expect(math.abs(result.im)).toBeCloseTo(0, 10);
     36|     });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[25/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Known values from Varshalovich > should calculate {3/2 3/2 3; 3/2 3/2 0} = -1/(2âˆš5)
AssertionError: expected -0.000049603174603174596 to be close to -0.22360679774997896, received difference is 0.2235571945753758, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:40:25
     38|     it('should calculate {3/2 3/2 3; 3/2 3/2 0} = -1/(2âˆš5)', () => {
     39|       const result = wigner6j(1.5, 1.5, 3, 1.5, 1.5, 0);
     40|       expect(result.re).toBeCloseTo(-1/(2*Math.sqrt(5)), 6);
       |                         ^
     41|       expect(math.abs(result.im)).toBeCloseTo(0, 10);
     42|     });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[26/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Special cases from theory > should handle zero argument case correctly
AssertionError: expected -0.013888888888888897 to be close to 0.3333333333333333, received difference is 0.3472222222222222, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:50:25
     48|       const result = wigner6j(1, 1, 1, 1, 1, 0);
     49|       const expected = (-1)**(1+1) * (1 === 1 ? 1/3 : 0); // delta_bc/â€¦
     50|       expect(result.re).toBeCloseTo(expected, 6);
       |                         ^
     51|     });
     52| 

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[27/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Special cases from theory > should handle equal pairs case correctly
AssertionError: expected 0.000277777777777778 to be close to 0.1, received difference is 0.09972222222222223, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:57:25
     55|       const result = wigner6j(1, 1, 2, 1, 1, 2);
     56|       // Expected value from Varshalovich Table
     57|       expect(result.re).toBeCloseTo(1/10, 6);
       |                         ^
     58|     });
     59|   });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[28/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Symmetry properties > should satisfy Regge symmetry
AssertionError: expected 0.000277777777777778 to be close to 0.0003105649968749709, received difference is 0.00003278721909719291, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:71:27
     69|       const original = wigner6j(1, 1, 2, 1, 1, 2);
     70|       const regge = wigner6j(1, 1, 1, 2, 2, 1);    // Regge symmetry
     71|       expect(original.re).toBeCloseTo(regge.re, 6);
       |                           ^
     72|     });
     73|   });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[29/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Sum rules > should satisfy orthogonality relation
AssertionError: expected 0.00001388888888888891 to be close to 0.3333333333333333, received difference is 0.33331944444444445, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:83:19
     81|         sum += (2*j + 1) * symbol.re * symbol.re;
     82|       }
     83|       expect(sum).toBeCloseTo(1/(2*l2 + 1), 6);
       |                   ^
     84|     });
     85| 

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[30/34]â¯

 FAIL  __tests__/angularMomentum/wigner6j.test.ts > Wigner 6j Symbols > Sum rules > should satisfy Racah backcoupling rule
AssertionError: expected -0.010416666666666671 to be close to 1, received difference is 1.0104166666666667, but expected 5e-7
 â¯ __tests__/angularMomentum/wigner6j.test.ts:95:19
     93|         }
     94|       }
     95|       expect(sum).toBeCloseTo(1, 6);
       |                   ^
     96|     });
     97|   });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[31/34]â¯

 FAIL  __tests__/geometry/quantumDistance.test.ts > Bloch Sphere Geometry > quantum distance matches Bloch sphere calculation
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 â¯ __tests__/geometry/quantumDistance.test.ts:112:23
    110|       const matches = BlochSphere.verifyQuantumDistance(theta1, phi1, â€¦
    111|       console.log(`Bloch sphere verification: `, matches);
    112|       expect(matches).toBe(true);
       |                       ^
    113|     });
    114|   });
 â¯ __tests__/geometry/quantumDistance.test.ts:109:15

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[32/34]â¯

 Test Files  13 failed | 23 passed (36)
      Tests  29 failed | 422 passed (451)
   Start at  18:18:33
   Duration  3.72s (transform 473ms, setup 2ms, collect 16.57s, tests 907ms, environment 4ms, prepare 2.02s)

